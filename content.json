{"meta":{"title":"TinTin","subtitle":"吾日糁省五升！","description":"学习matlab/python/HTML5/c/c++/机器学习/贝叶斯网络中~~~","author":"TinTin","url":"https://tintingo.github.io"},"pages":[{"title":"下载","date":"2018-09-12T03:29:03.281Z","updated":"2018-07-11T08:48:43.008Z","comments":true,"path":"download.html","permalink":"https://tintingo.github.io/download.html","excerpt":"","text":"TT计划表安装包： 点击以上按钮即可下载 此文件为首页博文“用matlab制作一个小软件”中的软件安装包,解压密码到“关于”联系作者获取 贝叶斯工具箱BNT： 点击以上按钮即可下载 下载后将文件解压放到到Matlab安装目录的toolbox目录下,然后再在命令窗口下输入如下代码：addpath(genpath(‘D:...\\toolbox\\bnt_master’));savepath; 输入代码检验：which test_BNT.m 若返回路径则成功。 第一个MFC： 点击以上按钮即可下载 此文件为首页博文“第一个MFC”中的源程序 第一个Matlab-GUI： 点击以上按钮即可下载 此文件为首页博文“如何用Matlab设计GUI？”中的源程序 Matlab关联.m文件： 点击以上按钮即可下载 （1）解压后，运行matlab软件 - &gt;打开 - &gt; associateFiles.m - &gt; F5运行 （2）运行完毕后文件夹中会生成一个.reg的文件，双击该文件，完成即可（3）找一个.m文件，右键 - &gt;打开方式，若有matlab选项，说明关联成功 Matlab画柱状图： 点击以上按钮即可下载 此文件为画柱状图的matlab程序 中文文本分类语料库： 点击以上按钮即可下载 此文件为中文文本分类语料库，包含20多个类别"},{"title":"留言","date":"2018-09-12T03:29:03.281Z","updated":"2018-06-28T08:24:25.862Z","comments":true,"path":"comments.html","permalink":"https://tintingo.github.io/comments.html","excerpt":"","text":"# 欢迎留言讨论 #"},{"title":"生活馆","date":"2018-09-12T03:29:04.016Z","updated":"2018-06-28T08:23:46.053Z","comments":true,"path":"life.html","permalink":"https://tintingo.github.io/life.html","excerpt":"","text":"河北.秦皇岛.燕山大学.燕鸣湖河北.秦皇岛.燕山大学.未命名云南.曲靖.桃云南.昆明.竹云南.昆明.桥云南.曲靖.卷粉、凉粉河北.秦皇岛.燕山大学.楼河北.秦皇岛.燕山大学.灯河北.秦皇岛.燕山大学.光河北.秦皇岛.燕山大学.花"},{"title":"","date":"2018-09-12T03:29:03.656Z","updated":"2017-12-15T02:06:11.595Z","comments":true,"path":"images/about.html","permalink":"https://tintingo.github.io/images/about.html","excerpt":"","text":"about|TINTIN"}],"posts":[{"title":"机器学习算法精要","slug":"TT0016","date":"2018-06-26T02:43:28.189Z","updated":"2018-07-11T08:00:43.785Z","comments":true,"path":"2018/06/26/TT0016/","link":"","permalink":"https://tintingo.github.io/2018/06/26/TT0016/","excerpt":"本文为翻译文，原文来自：Essentials of Machine Learning Algorithms 广义而言，机器学习算法分三类1.监督学习工作原理：算法从一组给定的预测因子（独立变量）来预测目标/结果变量（或因变量），使用这些变量集生成映射输入到期望输出的函数，不断训练直到模型达到训练数据所需的精度水平。常见算法有：回归（Regression）、决策树（Decision Tree）、随机森林（Random Forest）、KNN、逻辑回归（Logistic Regression）等。 2.无监督学习工作原理：算法中没有任何目标或结果变量要预测/估计，而是用于不同群体的种群聚集，广泛应用于不同群体的细分。常见算法有：关联规则算法（Apriori algorithm）、K-means。 3.增强学习工作原理：算法中，机器被训练来做出特定的决定，通过反复试验不断训练机器，机器从过去的经验中学习，捕捉最好的知识以做出准确的决策。常见算法有：马尔科夫决策过程(Markov Decision Process)。","text":"本文为翻译文，原文来自：Essentials of Machine Learning Algorithms 广义而言，机器学习算法分三类1.监督学习工作原理：算法从一组给定的预测因子（独立变量）来预测目标/结果变量（或因变量），使用这些变量集生成映射输入到期望输出的函数，不断训练直到模型达到训练数据所需的精度水平。常见算法有：回归（Regression）、决策树（Decision Tree）、随机森林（Random Forest）、KNN、逻辑回归（Logistic Regression）等。 2.无监督学习工作原理：算法中没有任何目标或结果变量要预测/估计，而是用于不同群体的种群聚集，广泛应用于不同群体的细分。常见算法有：关联规则算法（Apriori algorithm）、K-means。 3.增强学习工作原理：算法中，机器被训练来做出特定的决定，通过反复试验不断训练机器，机器从过去的经验中学习，捕捉最好的知识以做出准确的决策。常见算法有：马尔科夫决策过程(Markov Decision Process)。 常用机器学习算法1.线性回归 - Linear Regression2.逻辑回归 - Logistic Regression3.决策树 - Decision Tree4.支持向量机 - SVM5.朴素贝叶斯 - Naive Bayes6.邻近算法 - kNN7.K均值 - K-Means8.随机森林 - Random Forest9.降维算法 - Dimensionality Reduction Algorithms10.梯度提升算法 - Gradient Boosting algorithms （GBM、XGBoost、LightGBM、CatBoost） 一、线性回归（Linear Regression）线性回归是用连续变量来估计实际值（房屋成本、通话次数、总销售额等）,通过拟合一条最佳的线来建立自变量和因变量之间的关系，这个最佳拟合线称为回归线，用线性方程y = a*x + b表示。了解线性回归的最好方法是重温童年的经历。要求一个第五年级的孩子通过体重的递增顺序来给他班上的学生排队，在不给出他们的体重的情况下，你认为这个孩子会怎么做？他（她）可能会观察他们的身高和身材（视觉分析），并综合这些可见参数给他们排队。这就是现实生活中的线性回归！这个孩子实际上已经知道身高和身材与体重的关系是由一种像上面的等式关系决定的。等式中，y为因变量，x为自变量，a为斜率，b为截距。系数a和b可通过极小化数据点与回归线之间的距离的平方差之和获得。如下例中，已经确定了线性方程y = 0.2811x + 13.9为最佳拟合线，用这个方程式，通过体重，就可知道一个人的身高。线性回归主要有两类：简单线性回归和多元线性回归。简单线性回归的特点是一个自变量，多元线性回归的特征是多个（1个以上）自变量。在寻找最佳拟合线时，可以拟合多项式或曲线回归，这被称为多项式或曲线回归。python代码123456789101112131415161718#Import Library#Import other necessary libraries like pandas, numpy...from sklearn import linear_model#Load Train and Test datasets#Identify feature and response variable(s) and values must be numeric and numpy arraysx_train=input_variables_values_training_datasetsy_train=target_variables_values_training_datasetsx_test=input_variables_values_test_datasets# Create linear regression objectlinear = linear_model.LinearRegression()# Train the model using the training sets and check scorelinear.fit(x_train, y_train)linear.score(x_train, y_train)#Equation coefficient and Interceptprint('Coefficient: \\n', linear.coef_)print('Intercept: \\n', linear.intercept_)#Predict Outputpredicted= linear.predict(x_test) R代码1234567891011#Load Train and Test datasets#Identify feature and response variable(s) and values must be numeric and numpy arraysx_train &lt;- input_variables_values_training_datasetsy_train &lt;- target_variables_values_training_datasetsx_test &lt;- input_variables_values_test_datasetsx &lt;- cbind(x_train,y_train)# Train the model using the training sets and check scorelinear &lt;- lm(y_train ~ ., data = x)summary(linear)#Predict Outputpredicted= predict(linear,x_test) 二、逻辑回归（Logistic Regression）不要被它的名字混淆！它是一种分类而不是回归算法。它是用来估计基于给定自变量集的离散值（二进制值，如0/1，是/否，真/假）。简单地说，它通过将数据拟合到对数函数来预测事件发生的概率，因此，它也被称为对数回归。由于它预测了概率，其输出值介于0和1之间。再一次通过一个简单的例子来理解一下。假设你的朋友给你一个难题来解决，只有2种结果：解决、没解决。现在想象一下，机器通过给你做各种各样的测试来试图了解你擅长的科目，学习的结果将是这样的：如果给你一个十年级的三重测量问题，你有70%的概率来解决这个问题。另一方面，如果是五年级的历史问题，你只有30%的概率来解决这个问题。在数学中，结果的对数几率（log odds：对数几率odds是体现阳性和阴性差异的这么一个指标）被模拟成预测变量的线性组合。123odds = p/ (1-p) 【事件发生可能性 / 事件发生可能性】ln(odds) = ln(p/(1-p))logit(p) = ln(p/(1-p)) = b0 + b1X1 + b2X2 + b3X3 + ... + bkXk 如上，P是存在目标特征的概率，它选择观察样本值的最大似然参数，而不选择普通回归中最小平方误差和。现在，你可能会问，为什么要选择log函数？为了简单起见，只能说这是复制阶跃函数最好的数学方法之一。Python代码12345678910111213#Import Libraryfrom sklearn.linear_model import LogisticRegression#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create logistic regression objectmodel = LogisticRegression()# Train the model using the training sets and check scoremodel.fit(X, y)model.score(X, y)#Equation coefficient and Interceptprint('Coefficient: \\n', model.coef_)print('Intercept: \\n', model.intercept_)#Predict Outputpredicted= model.predict(x_test) R代码123456x &lt;- cbind(x_train,y_train)# Train the model using the training sets and check scorelogistic &lt;- glm(y_train ~ ., data = x,family='binomial')summary(logistic)#Predict Outputpredicted= predict(logistic,x_test) 除此之外，为了改进模型，还可以尝试更多不同的步骤：包括交互项、去除特征、正则化、使用非线性模型。 三、决策树（Decision Tree）决策树是一种主要用于分类问题的监督学习算法，它适用于分类和连续因变量。在该算法中，我们将种群分成两个或更多的同质集，采用关键属性/自变量来尽可能区分的不同组。在上图中，你可以看到，基于多个属性，种群被划分为四个不同的组，以确定“他们是否会玩”，采用Gini、信息增益、Chi平方、熵等多种算法将种群划分为不同的异质集。了解决策树是如何运作的最好方法是玩Jezzball——一个经典的微软游戏（下图）。本质上，你有一个带有可移动墙的房间，你需要创建墙壁能够清除最大的没有球的区域。所以，每次你用墙分开房间时，你试图在同一个房间里创造2个不同的群体。决策树方式工作非常相似，就是尽可能的将种群划分为不同的组。了解更多：简化的决策树算法版本Python代码123456789101112#Import Library#Import other necessary libraries like pandas, numpy...from sklearn import tree#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create tree object model = tree.DecisionTreeClassifier(criterion='gini') # for classification, here you can change the algorithm as gini or entropy (information gain) by default it is gini # model = tree.DecisionTreeRegressor() for regression# Train the model using the training sets and check scoremodel.fit(X, y)model.score(X, y)#Predict Outputpredicted= model.predict(x_test) R代码1234567library(rpart)x &lt;- cbind(x_train,y_train)# grow tree fit &lt;- rpart(y_train ~ ., data = x,method=\"class\")summary(fit)#Predict Output predicted= predict(fit,x_test) 四、SVM (Support Vector Machine)SVM是一种分类方法。在该算法中，我们将每个数据项绘制为n维空间中的一个点（其中n是具有的特征数），其中每个特征的值是特定坐标的值。例如，若我们只有两个特征，身高和头发长度，我们首先在二维空间中绘制这两个变量，其中每个点有两个坐标（这些坐标被称为支持向量）。现在，我们将找到一条分割两个不同分类数据集之间的数据的线，这是一条直线，使得两组中最靠近的点的距离最远。在上面的例子中，将数据分割成两个不同的类的线是黑线，因为这两个最靠近的点离直线最远，这条线就是我们的分类器。这样，看测试数据落在该线的哪一边，就可将新数据分为什么类。了解更多：支持向量机的简化版本Python代码12345678910#Import Libraryfrom sklearn import svm#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create SVM classification object model = svm.svc() # there is various option associated with it, this is simple for classification. You can refer link, for mo# re detail.# Train the model using the training sets and check scoremodel.fit(X, y)model.score(X, y)#Predict Outputpredicted= model.predict(x_test) R代码1234567library(e1071)x &lt;- cbind(x_train,y_train)# Fitting modelfit &lt;-svm(y_train ~ ., data = x)summary(fit)#Predict Output predicted= predict(fit,x_test) 五、朴素贝叶斯朴素贝叶斯是一种基于贝叶斯定理的分类算法，具有预测属性之间的独立性假设。简单地说，朴素贝叶斯分类器假定类中的特定特征的存在与任何其他特征的存在无关。例如，如果一个水果是红色的、圆的、直径约3英寸的，它可以被认为是一个苹果。即使这些特征彼此依赖或存在其他特征，朴素贝叶斯分类器也认为所有这些属性对“这种水果是苹果”贡献的概率是独立的。朴素贝叶斯模型易于建立，特别适用于非常大的数据集。由于它简单，朴素贝叶斯甚至被认为优于其他高度复杂的分类方法。贝叶斯定理为通过P(C)、P(X)和P(X|C)来计算后验概率p(C|x)提供了一种途径。请看下面的方程式：其中，P(C|x)是给定（待测）属性的类（目标）的后验概率,P(C)是类的先验概率,P(x|c)是给定类情况下待测属性出现的概率,P(x)是待测属性的先验概率。例：有一个包含天气和相应的目标变量“玩”的训练数据集，现在，我们需要根据天气情况来判断是否可以去玩。按如下步骤执行：第1步：将数据集转换为频率表第2步：通过比如阴天的概率为0.29和去玩的概率为0.64来创建似然表。第3步：使用朴素贝叶斯公式计算每个类的后验概率，具有最高后验概率的类就是预测结果。问题：如果天气晴朗会去玩，这个说法正确吗？我们可以用上面讨论的方法求解它，P(Yes | Sunny) = P( Sunny | Yes) P(Yes) / P (Sunny)表中可知：P (Sunny |Yes) = 3/9 = 0.33, P(Sunny) = 5/14 = 0.36, P(Yes)= 9/14 = 0.64那么，P (Yes | Sunny) = 0.33 0.64 / 0.36 = 0.60，具有较高的概率。朴素贝叶斯使用类似的方法来预测各属性的不同类别的概率，该算法主要用于文本分类和多分类问题。Python代码12345678#Import Libraryfrom sklearn.naive_bayes import GaussianNB#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create SVM classification object model = GaussianNB() # there is other distribution for multinomial classes like Bernoulli Naive Bayes, Refer link# Train the model using the training sets and check scoremodel.fit(X, y)#Predict Outputpredicted= model.predict(x_test) R代码1234567library(e1071)x &lt;- cbind(x_train,y_train)# Fitting modelfit &lt;-naiveBayes(y_train ~ ., data = x)summary(fit)#Predict Output predicted= predict(fit,x_test) 六、kNN (k- Nearest Neighbors)KNN可以用于分类和回归问题，而在工业上常用在分类问题上。K近邻算法是一种简单的算法，它存储了所有可用的样本，并通过其k领域的多数表决对新的样本进行分类。样本的分类是K近邻范围内所有点通过距离函数测量的多数共识。这些距离函数可以是欧几里得（Euclidean）、曼哈顿（Manhattan）、闵可夫斯基（Minkowski）和汉明（Hamming）距离，前三个函数用于连续函数，第四个（Hamming）用于分类变量，如果k＝1，则将该情况简单地分给其最近邻的类。在进行KNN建模时，选择K值是最大的难点。KNN可以很容易地映射到我们的真实生活中，如果你想了解一个人，你没有他/她的信息，你可能从他的亲密朋友和他的圈子获得他/她的信息。选择KNN之前要考虑的事项：1.KNN运行较耗时；2.变量需归一化，否则较高的范围变量会对它产生偏差；3.在KNN之前需进行如离群点、去噪的预处理工作。Python代码123456789#Import Libraryfrom sklearn.neighbors import KNeighborsClassifier#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create KNeighbors classifier object model KNeighborsClassifier(n_neighbors=6) # default value for n_neighbors is 5# Train the model using the training sets and check scoremodel.fit(X, y)#Predict Outputpredicted= model.predict(x_test) R代码1234567library(knn)x &lt;- cbind(x_train,y_train)# Fitting modelfit &lt;-knn(y_train ~ ., data = x,k=5)summary(fit)#Predict Output predicted= predict(fit,x_test) 七、K-MeansK-Means是一种解决聚类问题的无监督算法。它的过程遵循一种简单且容易的方式，通过一定数量的簇（给定k簇）对给定的数据集进行分类。集群内的数据点对于每组是同质的和异质的。记得从墨迹中找出形状吗？K-Means就能做类似的活动，通过观察形状能够辨认出多少不同的簇/种群存在。K-means如何形成集群：1.K-means为每个集群挑选K个点，称为质心。2.每个数据点形成具有最接近质心的簇，即K簇。3.根据现有的群集成员查找每个簇的质心，以获得新的质心。4.当有了新的质心时，重复第2步和第3步。从新的质心找到每个数据点最近的距离，并与新的K簇关联。重复这个过程直到收敛，即质心不变。如何确定K值：在K-means中有簇，且每个簇都有它自己的质心。簇中质心与数据点之间差的平方之和构成该簇的平方值之和，当所有簇的平方值之和被添加时，也就有了簇解的平方值总和。我们知道，随着簇的数量增加，这个值持续减小，但若绘出结果图，会看到平方距离的总和急剧下降到某个值：K，然后缓慢下降，这样就可以找到最佳的簇数。Python代码123456789#Import Libraryfrom sklearn.cluster import KMeans#Assumed you have, X (attributes) for training data set and x_test(attributes) of test_dataset# Create KNeighbors classifier object model k_means = KMeans(n_clusters=3, random_state=0)# Train the model using the training sets and check scoremodel.fit(X)#Predict Outputpredicted= model.predict(x_test) R代码12library(cluster)fit &lt;- kmeans(X, 3) # 5 cluster solution 八、随机森林随机森林是一个包含多个决策树的分类器，它是决策树的集合（被称为“森林”）。为了根据属性对新对象进行分类，每个树都给出分类，并称树为该类“投票”，森林选择选票最多的分类（遍及森林中的所有树）。树生成如下：1.如果训练集中的样本数为N，则随机抽取N个样本，但有放回，这个样本便是生成树的训练集。2.如果有M个输入变量，在每个节点处指定一个远小于M的数m，从M中随机选择m个变量，并这些m上的最佳分割用于分割节点。在森林生长过程中，m的值保持不变。3.每棵树尽可能最大的生长，没有修剪。关于该算法的更多细节，与决策树和调谐模型参数进行比较，我建议您阅读这些文章：1.随机森林简介2.CART模型与随机森林的比较（第1部分）3.随机森林与CART模型的比较（第2部分）4.调整随机森林模型的参数Python代码123456789#Import Libraryfrom sklearn.ensemble import RandomForestClassifier#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create Random Forest objectmodel= RandomForestClassifier()# Train the model using the training sets and check scoremodel.fit(X, y)#Predict Outputpredicted= model.predict(x_test) R代码1234567library(randomForest)x &lt;- cbind(x_train,y_train)# Fitting modelfit &lt;- randomForest(Species ~ ., x,ntree=500)summary(fit)#Predict Output predicted= predict(fit,x_test) 九、降维算法在过去的4-5年中，数据捕获在每一个可能的阶段都呈指数增长。企业/政府机构/研究机构不仅不断地有新的资源出现，而且还要非常详细地捕捉数据。比如电子商务公司正在捕捉更多关于客户的细节，如他们的人口数据、网络浏览历史、他们喜欢或不喜欢的东西、购买历史、反馈和其他许多信息，以比他们最近的杂货店店主更个性化地关注他们。作为一个数据科学家，我们所提供的数据也包含许多特征，这对于建立良好的鲁棒模型很有帮助，但是存在一个挑战，如何从一两千的数据中找到较主要的变量？在这种情况下，降维算法有助于结合决策树、随机森林、PCA、因子分析、基于相关矩阵、缺失值比率等多种算法进行识别。要知道更多关于这个算法，你可以阅读“学习降维算法初学者指南”。Python代码1234567891011#Import Libraryfrom sklearn import decomposition#Assumed you have training and test data set as train and test# Create PCA obeject pca= decomposition.PCA(n_components=k) #default value of k =min(n_sample, n_features)# For Factor analysis#fa= decomposition.FactorAnalysis()# Reduced the dimension of training dataset using PCAtrain_reduced = pca.fit_transform(train)#Reduced the dimension of test datasettest_reduced = pca.transform(test)#For more detail on this, please refer this link. R代码1234library(stats)pca &lt;- princomp(train, cor = TRUE)train_reduced &lt;- predict(pca,train)test_reduced &lt;- predict(pca,test) 十、梯度提升算法十点一、GBMGBM是一种利用大量数据进行预测的Boosting算法（Boosting算法是一种用来提高弱分类算法准确度的方法），具有很高的预测能力。实际上，Boosting是学习算法的一种综合，它结合了多个基估计的预测，以提高单个估计器的鲁棒性。它将多个弱预测因子或平均预测因子组合成一个强预测因子。这些Boosting算法在Kaggle、AV Hakason、CrowdAnalytix等数据科学竞赛中有很好。了解更多：详细了解Boosting算法Python代码123456789#Import Libraryfrom sklearn.ensemble import GradientBoostingClassifier#Assumed you have, X (predictor) and Y (target) for training data set and x_test(predictor) of test_dataset# Create Gradient Boosting Classifier objectmodel= GradientBoostingClassifier(n_estimators=100, learning_rate=1.0, max_depth=1, random_state=0)# Train the model using the training sets and check scoremodel.fit(X, y)#Predict Outputpredicted= model.predict(x_test) R代码123456library(caret)x &lt;- cbind(x_train,y_train)# Fitting modelfitControl &lt;- trainControl( method = \"repeatedcv\", number = 4, repeats = 4)fit &lt;- train(y ~ ., data = x, method = \"gbm\", trControl = fitControl,verbose = FALSE)predicted= predict(fit,x_test,type= \"prob\")[,2] 梯度提升分类器和随机森林是两种不同的提升树分类器，两种算法间的差异。 十点二、XGBoost另一种经典的梯度提升算法通常是一些Kaggle比赛中成败的决定性选择。XGBoost具有非常高的预测能力，这使得它成为事件精度的最佳选择。因为它同时具有线性模型和树学习算法，使得该算法比现有的梯度提升算法快近10倍。XGBoost支持包括各种目标函数，包括回归、分类和排序。XGBoost最有趣的事情之一是它也被称为一种正则提升算法，它助于减少过拟合建模，并且对Scala、Java、R、Python、Julia和C++等多种语言有很好的支持。支持分布式训练和广泛训练，包括GCE，AWS，Azure和Yarn-clusters等许多机器。XGBoosting还可以与Spark、Flink和其他云数据流系统集成，并在Boosting进程的每一次迭代中进行内置的交叉验证。有关XGBoost和参数调整的更多信息，点这里。Python代码1234567891011from xgboost import XGBClassifierfrom sklearn.model_selection import train_test_splitfrom sklearn.metrics import accuracy_scoreX = dataset[:,0:10]Y = dataset[:,10:]seed = 1X_train, X_test, y_train, y_test = train_test_split(X, Y, test_size=0.33, random_state=seed)model = XGBClassifier()model.fit(X_train, y_train)#Make predictions for test datay_pred = model.predict(X_test) R代码12345678require(caret)x &lt;- cbind(x_train,y_train)# Fitting modelTrainControl &lt;- trainControl( method = \"repeatedcv\", number = 10, repeats = 4)model&lt;- train(y ~ ., data = x, method = \"xgbLinear\", trControl = TrainControl,verbose = FALSE)OR model&lt;- train(y ~ ., data = x, method = \"xgbTree\", trControl = TrainControl,verbose = FALSE)predicted &lt;- predict(model, x_test) 十点三、LightGBMLightGBM是一种使用基于树的学习算法的梯度提升框架。它被设计成分布式的、高效的，优点如下：.更快的训练速度和更高的效率.低内存.高精度.支持并行GPU学习.能够处理大规模数据该框架是一种基于决策树算法的快速和高性能的梯度提升算法，用于排序、分类和许多其他机器学习任务。它是在微软的分布式机器学习工具包项目下开发的。由于LightGBM是一种基于决策树的算法，LightGBM使用leaf-wise的树生长策略，而很多其他boosting算法采用depth-wise和level-wise的树生长策略。因此，LightGBM中，当在同一片叶子上生长时，leaf-wise算法可以比level-wise算法减少更多的损失，从而得到更高的精度，这是任何现有的Boosting算法很少能实现的。与depth-wise和level-wise的树生长策略相比，leaf-wise策略可以收敛的更快。此外，因为LightGBM算法速度非常快，因此用“Light”这个词。参考文章了解更多关于LightGBM：点这里。Python代码123456789101112data = np.random.rand(500, 10) # 500 entities, each contains 10 featureslabel = np.random.randint(2, size=500) # binary targettrain_data = lgb.Dataset(data, label=label)test_data = train_data.create_valid('test.svm')param = &#123;'num_leaves':31, 'num_trees':100, 'objective':'binary'&#125;param['metric'] = 'auc'num_round = 10bst = lgb.train(param, train_data, num_round, valid_sets=[test_data])bst.save_model('model.txt')# 7 entities, each contains 10 featuresdata = np.random.rand(7, 10)ypred = bst.predict(data) R代码1234567891011121314151617library(RLightGBM)data(example.binary)#Parametersnum_iterations &lt;- 100config &lt;- list(objective = \"binary\", metric=\"binary_logloss,auc\", learning_rate = 0.1, num_leaves = 63, tree_learner = \"serial\", feature_fraction = 0.8, bagging_freq = 5, bagging_fraction = 0.8, min_data_in_leaf = 50, min_sum_hessian_in_leaf = 5.0)#Create data handle and boosterhandle.data &lt;- lgbm.data.create(x)lgbm.data.setField(handle.data, \"label\", y)handle.booster &lt;- lgbm.booster.create(handle.data, lapply(config, as.character))#Train for num_iterations iterations and eval every 5 stepslgbm.booster.train(handle.booster, num_iterations, 5)#Predictpred &lt;- lgbm.booster.predict(handle.booster, x.test)#Test accuracysum(y.test == (y.pred &gt; 0.5)) / length(y.test)#Save model (can be loaded again via lgbm.booster.load(filename))lgbm.booster.save(handle.booster, filename = \"/tmp/model.txt\") 如果您熟悉R中的Caret包的话，以下是实现LightGBM的另一种方式：12345678910111213require(caret)require(RLightGBM)data(iris)model &lt;-caretModel.LGBM()fit &lt;- train(Species ~ ., data = iris, method=model, verbosity = 0)print(fit)y.pred &lt;- predict(fit, iris[,1:4])library(Matrix)model.sparse &lt;- caretModel.LGBM.sparse()#Generate a sparse matrixmat &lt;- Matrix(as.matrix(iris[,1:4]), sparse = T)fit &lt;- train(data.frame(idx = 1:nrow(iris)), iris$Species, method = model.sparse, matrix = mat, verbosity = 0)print(fit) 十点四、CatboostCatboost是最近从Yandex开源的机器学习算法，它可以很容易地与谷歌的TensorFlow和苹果的Core ML等深度学习框架相结合。关于Catboost最好的部分是，它不像其他ML模型那样需要大量的数据训练，并且可以工作在各种数据格式上，而不破坏它的鲁棒性。在执行之前，务必确保处理好缺失数据。CATBooST可以自动处理分类变量而不显示类型的转换误差，这有助于您更好地调整模型，而不是去挑出微小的误差。了解更多关于Catboost：从这篇文章。Python代码12345678910111213141516171819202122import pandas as pdimport numpy as npfrom catboost import CatBoostRegressor#Read training and testing filestrain = pd.read_csv(\"train.csv\")test = pd.read_csv(\"test.csv\")#Imputing missing values for both train and testtrain.fillna(-999, inplace=True)test.fillna(-999,inplace=True)#Creating a training set for modeling and validation set to check model performanceX = train.drop(['Item_Outlet_Sales'], axis=1)y = train.Item_Outlet_Salesfrom sklearn.model_selection import train_test_splitX_train, X_validation, y_train, y_validation = train_test_split(X, y, train_size=0.7, random_state=1234)categorical_features_indices = np.where(X.dtypes != np.float)[0]#importing library and building modelfrom catboost import CatBoostRegressormodel=CatBoostRegressor(iterations=50, depth=3, learning_rate=0.1, loss_function='RMSE')model.fit(X_train, y_train,cat_features=categorical_features_indices,eval_set=(X_validation, y_validation),plot=True)submission = pd.DataFrame()submission['Item_Identifier'] = test['Item_Identifier']submission['Outlet_Identifier'] = test['Outlet_Identifier']submission['Item_Outlet_Sales'] = model.predict(test) R代码1234567891011121314set.seed(1)require(titanic)require(caret)require(catboost)tt &lt;- titanic::titanic_train[complete.cases(titanic::titanic_train),]data &lt;- as.data.frame(as.matrix(tt), stringsAsFactors = TRUE)drop_columns = c(\"PassengerId\", \"Survived\", \"Name\", \"Ticket\", \"Cabin\")x &lt;- data[,!(names(data) %in% drop_columns)]y &lt;- data[,c(\"Survived\")]fit_control &lt;- trainControl(method = \"cv\", number = 4,classProbs = TRUE)grid &lt;- expand.grid(depth = c(4, 6, 8),learning_rate = 0.1,iterations = 100, l2_leaf_reg = 1e-3, rsm = 0.95, border_count = 64)report &lt;- train(x, as.factor(make.names(y)),method = catboost.caret,verbose = TRUE, preProc = NULL,tuneGrid = grid, trControl = fit_control)print(report)importance &lt;- varImp(report, scale = FALSE)print(importance) 至止，你将对常用的机器学习算法有所了解。","categories":[],"tags":[]},{"title":"大学发明专利申请","slug":"TT0015","date":"2018-06-11T07:22:22.064Z","updated":"2018-07-16T00:48:43.663Z","comments":true,"path":"2018/06/11/TT0015/","link":"","permalink":"https://tintingo.github.io/2018/06/11/TT0015/","excerpt":"本文适用于在大学（本科生、硕士研究生、博士研究生等）校内申请发明专利者，其内容主要分享在大学发明专利申请的经验，不代表所有学校申请流程都是如此。（本文经验以燕山大学申请为例）","text":"本文适用于在大学（本科生、硕士研究生、博士研究生等）校内申请发明专利者，其内容主要分享在大学发明专利申请的经验，不代表所有学校申请流程都是如此。（本文经验以燕山大学申请为例） 申请前准备发明专利申请对于从来没有申请过的菜鸟来说（比如我自己）可能显得有些难，有种畏惧感是很正常滴！导师说：“小伙计！你做的这个东西可以申请个专利！”时，那就有喜有悲啦！喜的是，哇！有可以加分领奖学金啦！简历内容又多一行啦！悲的是，哇哦！这个怎么写呀！完全摸不着下巴（更别说摸到头脑啦！）。所以，上网搜寻点经验是有必要滴（除非有老司机带你）！可能你搜来索去找不到合适的经验，那么，就需要本文这样的经验啦（新手上路！多多包涵！我还不系老司机）！ 第一步：浏览校内技术转移中心网站一定要相信你学校，她早就帮你想好了！她知道你要写专利，所以她专门为你设有网站、知识产权办公室、专利代理机构等。哇！好贴心哦！到你学校的技术转移中心网站上找到“知识产权”,查看相关流程，并下载表格。如下图所示。申请流程如下：看如上申请流程我们知道，在向学校知识产权办公室提交申请材料之前，需要先进行查新。 第二步：专利查新专利查新的话有两种选择：1.自己查（就是检索国内外文献和专利，证明你的东西是新的！！–免费哦）；2.找查新机构查。（–花钱哦）小弟弟初来乍到，不了解情况，所以就选择了查新机构查新，费用：600元。查新机构的话好像有的学校有，有的学校没有，没有就需要到校外找啦！（燕山大学有，就在图书馆，网址：http://kjcx.ysu.edu.cn/）查新流程如下：简单点说就是：1.下载并填写科技查新委托书，邮件发送到查新机构邮箱（或者亲自送去）；2.机构收到后会联系你，确认后就会通过QQ或者邮箱什么的与你交流相关查新内容；3.查新完成，缴费领取报告。 第三步：撰写专利申请材料到你学校的技术转移中心网站上找到“知识产权”,下载专利申请相关表格。其中，包括如下图所示的几个表格。按要求撰写专利申请材料，写完后准备将材料提交到知识产权办公室。 第四步：提交申请材料将查新报告和发明专利申请审批表及委托书提交到知识产权办公室，对方会给你一个编号，最后将之前撰写好的申请材料以压缩格式发到指定邮箱。 第五步：与代理进行技术交流提交完申请材料后，代理机构将先通过邮件与你联系，并随时发邮件向你通报撰写情况，进行技术交流时，代理机构负责撰写申请材料的技术人员将会与你电话联系，交流相关专利的技术细节。经过技术交流后，负责撰写案件文稿的工程师会根据你的提交的文件（说明书和权利要求书）重新撰写，工程师完成案件初稿后会将初稿以邮件的方式发送给你，并要求你从技术角度进行审核，有问题的话，就以修订模式进行修改或采用其他保留痕迹的方式修改。没有问题的话，回复“审核无误，可以提交”，代理机构将进行后续流程的。 第六步：定稿确认，提交确认函无论是需要修改还是不需要修改，在最终确认定稿后，代理机构将发送如下图所示的邮件给你，文中要求把确认表，确认函以及权利要求书打印出来签字交到学校知识产权代理机构办公室。交完后，代理将帮你向国家专利局提出专利申请。 注意，上述3个文件都要签字！ 第七步：国家专利局受理代理机构向国家专利局提出专利申请，提交申请后，国家专利局会向代理机构发回“受理通知书”，同时，代理机构也将该“受理通知书”发一份给你，要你保存一份。下一步等待更新中~~~~","categories":[],"tags":[]},{"title":"贝叶斯网络学习","slug":"TT0014","date":"2018-06-06T01:03:13.027Z","updated":"2018-07-05T01:58:16.927Z","comments":true,"path":"2018/06/06/TT0014/","link":"","permalink":"https://tintingo.github.io/2018/06/06/TT0014/","excerpt":"贝叶斯网络是一种概率网络，它是基于概率推理的图形化网络，而贝叶斯公式则是这个概率网络的基础。贝叶斯网络是基于概率推理的数学模型，所谓概率推理就是通过一些变量的信息来获取其他的概率信息的过程，基于概率推理的贝叶斯网络(Bayesian network)是为了解决不定性和不完整性问题而提出的，它对于解决复杂设备不确定性和关联性引起的故障有很大的优势，在多个领域中获得广泛应用。【来源：百度百科】","text":"贝叶斯网络是一种概率网络，它是基于概率推理的图形化网络，而贝叶斯公式则是这个概率网络的基础。贝叶斯网络是基于概率推理的数学模型，所谓概率推理就是通过一些变量的信息来获取其他的概率信息的过程，基于概率推理的贝叶斯网络(Bayesian network)是为了解决不定性和不完整性问题而提出的，它对于解决复杂设备不确定性和关联性引起的故障有很大的优势，在多个领域中获得广泛应用。【来源：百度百科】 读综述文章，初步了解贝叶斯网络读完以下4篇文献，你将对贝叶斯网络有个初步的了解！！！（1）《贝叶斯网络发展及其应用综述》【黄影平. 贝叶斯网络发展及其应用综述[J]. 北京理工大学学报, 2013, 33(12):1211-1219.】（2）《贝叶斯网络研究综述》【胡春玲. 贝叶斯网络研究综述[J]. 合肥学院学报(综合版), 2013, 23(1):33-40.】（3）《贝叶斯网络结构学习综述》【李硕豪, 张军. 贝叶斯网络结构学习综述[J]. 计算机应用研究, 2015(3):641-646.】（4）《贝叶斯网络推理算法综述》【厉海涛, 金光, 周经伦,等. 贝叶斯网络推理算法综述[J]. 系统工程与电子技术, 2008, 30(5):935-939.】 实例出发，了解贝叶斯网络在做什么以下为一段贝叶斯网络训练的matlab代码，包括结构学习和参数学习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101% ********************************************************************* %% ************************ 贝叶斯网络实例 ***************************** %% ********************************************************************* %%clearclc% *********************************************************************** %% ……………………………………… 已知网络 ……………………………………………… %% *********************************************************************** %N = 5; % 4个节点dag = zeros(N,N); % dag为网络结构边的关系 E = 1; B = 2; R = 3; A = 4; C = 5; % 节点编号 dag(E,[R A]) = 1; % 节点加边dag(B,A) = 1; % 节点加边dag(A,C)=1; % 节点加边false = 1; true = 2; ns = 2*ones(1,N); % 节点可能的取值个数（这里为2个，取值为：0或1）bnet = mk_bnet(dag, ns); % 生成bnet，包括结构和参数（概率）bnet.CPD&#123;E&#125; = tabular_CPD(bnet, E, [0.1 0.9]);% 给各个节点添加先验概率bnet.CPD&#123;B&#125; = tabular_CPD(bnet, B, [0.01 0.99]);bnet.CPD&#123;R&#125; = tabular_CPD(bnet, R, [0.65 0.01 0.35 0.99]);bnet.CPD&#123;A&#125; = tabular_CPD(bnet, A, [0.95 0.8 0.3 0.001 0.05 0.2 0.7 0.999]);bnet.CPD&#123;C&#125; = tabular_CPD(bnet, C, [0.7 0.05 0.3 0.95]); % *********************************************************************** %% ……………………………………… 生成数据 ……………………………………………… %% *********************************************************************** %seed = 0; %seed表示采用v4版本的随机数产生器，state是v5版本的随机数产生器rand('state', seed); % 使用state指定状态，这样产生的随机结果相同，randn('state', seed); % 也就是说：你我生成的随机数相同，不论时间和地点ncases = 1000; data = zeros(N, ncases); for m=1:ncases data(:,m) = cell2num(sample_bnet(bnet)); % 根据以上生成的bnet生成随机样本end % *********************************************************************** %% ………………………………………1.结构学习……………………………………………… % % *********************************************************************** %order = [2,1,4,5,3]; % 定义节点序，节点序属于先验知识max_fan_in = 2; % 定义最大父节点个数，不超过总节点个数N % 结构学习（采用K2算法进行结构训练）dag2 = learn_struct_K2(data, ns, order, 'max_fan_in', max_fan_in, 'verbose', 'yes'); % [dags,~,~] = learn_struct_mcmc(data, ns);% Sum_dag = zeros(N,N);% for i=1:size(dags,2)% Sum_dag = Sum_dag+dags&#123;1,i&#125;;% end% dag2 = triu(Sum_dag);% for i=1:N% for j=1:N% if dag2(i,j)&gt;300% dag2(i,j) = 1;% else% dag2(i,j) = 0;% end% end% end% *********************************************************************** %% ………………………………………2.参数学习……………………………………………… % % *********************************************************************** % bnet2 = mk_bnet(dag2, ns); seed = 0; rand('state', seed); bnet2.CPD&#123;E&#125; = tabular_CPD(bnet2, E, 'clamped', 1, 'CPT', [0.1 0.9], 'prior_type', 'dirichlet', 'dirichlet_weight', 0); bnet2.CPD&#123;B&#125; = tabular_CPD(bnet2, B, 'prior_type', 'dirichlet', 'dirichlet_weight', 0); bnet2.CPD&#123;R&#125; = tabular_CPD(bnet2, R, 'prior_type', 'dirichlet', 'dirichlet_weight', 0); bnet2.CPD&#123;A&#125; = tabular_CPD(bnet2, A, 'prior_type', 'dirichlet', 'dirichlet_weight', 0); bnet2.CPD&#123;C&#125; = tabular_CPD(bnet2, C, 'prior_type', 'dirichlet', 'dirichlet_weight', 0); % 从完全观测数据找最大似然估计(maximumlikelihood estimator,MLE)bnet3 = learn_params(bnet2, data); % *********************************************************************** %% ……………………………………………3.推理……………………………………………… % % *********************************************************************** %engine = jtree_inf_engine(bnet3); % 联合树推理引擎ev = cell(1,N); % 添加证据ev&#123;C&#125; = 1; % 节点C出现ev&#123;R&#125; = 1; % 节点R出现engine = enter_evidence(engine, ev); % 向网络添加指定的证据mE = marginal_nodes(engine, E); % 计算节点E的边缘概率mB = marginal_nodes(engine, B); % 计算节点B的边缘概率% *********************************************************************** %% …………………………………………… 结果显示 ………………………………………… % % *********************************************************************** %% （1）显示结构学习效果h1 = view(biograph( dag )); % 画出已知网络结构图h2 = view(biograph( dag2 )); % 画出学习网络结构图% （2）显示参数学习效果CPT3 = cell(1,N); for i=1:N s=struct(bnet.CPD&#123;i&#125;); CPT&#123;i&#125;=s.CPT; s1=struct(bnet3.CPD&#123;i&#125;); CPT3&#123;i&#125;=s1.CPT;endAA = [CPT&#123;1,4&#125;(:,:,1) CPT&#123;1,4&#125;(:,:,2)]; % 取了其中一个节点比较（节点A）BB = [CPT3&#123;1,4&#125;(:,:,1) CPT3&#123;1,4&#125;(:,:,2)];data = [[AA(1,:),AA(2,:)]' [BB(1,:),BB(2,:)]'];colnames = &#123;'原始概率' '学习概率'&#125;;figure;uitable('position',[0 80 200 200],'data',data,'ColumnName',colnames)% （3）显示推理结果msgbox(['P(E|C,R)=',num2str(mE.T(1)),'；P(B|C,R)=',num2str(mB.T(1)),' www.ttin.top']) 以上段代码解释如下： 首先：构建网络、生成数据。是窃贼还是地震？福尔摩斯先生在他的办公室工作时接到了他邻居华生的电话。华生告诉他：他的家里可能进了窃贼，因为他家的警铃响了。被告知有窃贼闯入，福尔摩斯迅速开车回家。在路上，他听广播得知他家那里发生了地震。地震也有可能引起警报。这样，请问福尔摩斯先生应该回家抓贼还是迅速撤离该地区以躲避地震？该贝叶斯网络为“是窃贼还是地震”模型，其中节点E表示地震（Earthquake）, 节点B表示盗窃（Burglary）, 节点R表示广播（Radio）, 节点A表示警铃（Alarm）, 节点C表示打电话（Call）其实就是我们对已知网络进行手动构建，一是为网络添加包括节点、边和方向的网络结构，二是为网络添加包括参数，即条件概率表（包括节点出现的先验概率和条件概率）。采用贝叶斯工具箱（BNT）中的sample_bnet函数对已知贝叶斯网络bnet进行随机采样，生成实验数据。 其次：结构学习采用K2算法对实验数据进行结构学习，贝叶斯工具箱（BNT）中的K2结构学习函数需要输入数据（data）, 节点可能的取值个数（ns）, 节点序（order）和最大父节点个数（max_fan_in）。从下图可以看出，经过结构学习后的结构和已知结构完全相同（该结构比较简单，且我们已知了节点序order（专家知识），所以拟合的比较好，但针对复杂结构可能就没那么好的效果了），说明该结构学习算法对数据拟合的比较好。 然后：参数学习采用最大似然估计算法对实验数据进行参数学习，先用第三部分结构学习后的网络结构生成一个bnet结构（bnet2 = mk_bnet(dag2, ns);），然后初始化bnet2的CPD，最后采用BNT工具箱中的参数学习行数对数据进行参数学习（bnet3 = learn_params(bnet2, data);）。学习结果如下表所示，从表中可以看，学习后的概率与预设概率接近。 最后：推理采用贝叶斯工具箱（BNT）中的联合树推理引擎，先是用jtree_inf_engine函数生成联合树推理引擎，然后用enter_evidence函数向网络添加证据（证据需放入cell中，放在矩阵中会出错，这是enter_evidence函数的输入格式要求），最后用marginal_nodes函数计算对应节点的边缘概率。计算出节点E和节点B的边缘概率mE.T(1)，即P(E|C,R)和mB.T(1)，即P(B|C,R)（虽然计算出来的是边缘概率P(E)和P(B)，但是在提供证据C,R出现的情况下推算出来的，所以也可看作后验概率P(E|C,R)和P(B|C,R)），并由P(E|C,R)和P(B|C,R)判断是地震还是窃贼。如图所示，推理结果为：P(E|C,R)=0.96081、P(B|C,R)=0.0033339，即在接到邻居华生的电话和听到广播得知他家那里发生了地震的情况下，他家发生地震的概率更大，福尔摩斯先生应迅速撤离该地区以躲避地震而不是回家抓贼。","categories":[],"tags":[]},{"title":"python常用代码记录","slug":"TT0013","date":"2018-06-05T07:01:15.502Z","updated":"2018-06-05T08:52:15.496Z","comments":true,"path":"2018/06/05/TT0013/","link":"","permalink":"https://tintingo.github.io/2018/06/05/TT0013/","excerpt":"悄悄记录下用过的一些python代码，以后再次用到时我就到这来找。嗯！不错！边学习边记录是个好习惯哦！不管啦！现在就要写。开始记录吧~~~~","text":"悄悄记录下用过的一些python代码，以后再次用到时我就到这来找。嗯！不错！边学习边记录是个好习惯哦！不管啦！现在就要写。开始记录吧~~~~ Matplotlib库Matplotlib是一个Python 2D绘图库。1.画正、余弦函数1234567891011121314151617181920# 导入matplotlib库的所有内容，from pylab import np# 创建图figure(figsize=(8,6), dpi=80)# 创建新子图subplot(1,1,1)# 定义正、余弦函数X = np.linspace(-np.pi, np.pi, 256,endpoint=True)C,S = np.cos(X), np.sin(X)# 绘制正弦曲线plot(X, C, color=\"blue\", linewidth=10, linestyle=\"-\")plot(X, S, color=\"red\", linewidth=10, linestyle=\"-\")# 设置x，y轴界限xlim(-4.0,4.0)ylim(-1.0,1.0)# 设置x，y轴标号xticks(np.linspace(-4,4,9,endpoint=True))yticks(np.linspace(-1,1,5,endpoint=True))# 显示show()","categories":[],"tags":[]},{"title":"如何用matlab制作一个小软件","slug":"TT0012","date":"2018-03-29T02:53:12.260Z","updated":"2018-07-11T08:55:15.360Z","comments":true,"path":"2018/03/29/TT0012/","link":"","permalink":"https://tintingo.github.io/2018/03/29/TT0012/","excerpt":"制作一个小软件的方法很多，比如说c++的MFC，本站在之前的第一个MFC文章里就提到过；matlab的GUIDE，在之前的如何用Matlab设计GUI？ 文章也提到过。而现在，本文将使用matlab GUI来制作一个可安装到电脑的小软件。","text":"制作一个小软件的方法很多，比如说c++的MFC，本站在之前的第一个MFC文章里就提到过；matlab的GUIDE，在之前的如何用Matlab设计GUI？ 文章也提到过。而现在，本文将使用matlab GUI来制作一个可安装到电脑的小软件。 提示：软件安装包请到本站下载中心下载(解压密码到“关于”联系作者获取) 首先，描述一下软件需求作者想制作一个可以为自己记录计划的软件，该软件应当包含以下功能：1.增加新计划，并保存计划；2.删除已有计划，更改当前计划；3.查看历史计划；4.显示当月日历，浏览其他日历（比如说查看学校校历等）； 其次，matlab GUI设计软件界面在本站前面内容已经提到过如何设计matlab GUI，在此就不做详细描述了。如下图所示，使用matlab GUI设计如下界面。其中，红色区域为主要功能区，其余部分可不设计。 然后，matlab 程序编写 访问日历网页（比如说查看学校校历等） 12txt = get(handles.edit1,'string');eval(['web',' ',txt]) 初始化当月计划 1set(handles.uitable1,'data',[]); 添加计划 12345678910content1 = get(handles.edit4,'string');content2 = get(handles.edit5,'string');content3 = get(handles.edit6,'string');uitabledata = get(handles.uitable1,'data');handles.uitabledata = uitabledata;guidata(hObject,handles);olddata = uitabledata;newrow = &#123;content1 content2 content3&#125;;newdata = [olddata;newrow];set(handles.uitable1,'data',newdata); 删除计划 12345678uitabledata = get(handles.uitable1,'data');handles.uitabledata = uitabledata;guidata(hObject,handles);olddata = uitabledata;[a,~] = size(olddata);olddata(a,:) = [];newdata = olddata;set(handles.uitable1,'data',newdata); 保存计划 123456uitabledata = get(handles.uitable1,'data');%写txt = get(handles.edit3,'string');filename = [txt(1:4),'_',txt(8:9),'.xls'];delete(filename)mytxt = xlswrite(filename,uitabledata); 查看以往计划 12345[pname,adrname] = uigetfile('*.xls');%读filename = [adrname pname];[~,~,rawdata] = xlsread(filename);set(handles.uitable1,'data',rawdata); 显示当月日历 12345678910111213dayunm = calendar(year(now),month(now));myday = num2cell(dayunm);myW1 = &#123;'日' '一' '二' '三' '四' '五' '六'&#125;;myW2 = &#123;'一';'二';'三';'四';'五';'六'&#125;;[a,b] = find(dayunm==day(now));myday&#123;a,b&#125; = ['&lt;html&gt;&lt;FONT color=#ff0000\"&gt;' num2str(myday&#123;a,b&#125;) '&lt;/Font&gt;&lt;/html&gt;'];[aa,bb] = find(dayunm==0);for i=1:size(aa) myday&#123;aa(i),bb(i)&#125; = ['&lt;html&gt;&lt;FONT color=#000000\"&gt;' num2str(myday&#123;aa(i),bb(i)&#125;) '&lt;/Font&gt;&lt;/html&gt;'];endset(handles.uitable2,'data',myday);set(handles.uitable3,'data',myW1);set(handles.uitable4,'data',myW2); 显示当月计划 123456789101112filename = [num2str(year(now)),'_',datestr(date,'mm'),'.xls'];if exist(filename,'file') == 0 uitabledata = &#123;'无计划' '无计划' '无计划'&#125;; mytxt = xlswrite(filename,uitabledata); %读 [~,~,rawdata] = xlsread(filename); set(handles.uitable1,'data',rawdata);else %读 [~,~,rawdata] = xlsread(filename); set(handles.uitable1,'data',rawdata);end 最后，软件打包在matlab命令行窗口输入deploytool，添加自己的文件后打包即可。（方法在百度上一搜索一大把！我就懒得说了！）","categories":[],"tags":[]},{"title":"VMware虚拟机安装Ubuntu如何联网？","slug":"TT0011","date":"2018-03-23T08:21:15.749Z","updated":"2018-06-05T07:03:16.244Z","comments":true,"path":"2018/03/23/TT0011/","link":"","permalink":"https://tintingo.github.io/2018/03/23/TT0011/","excerpt":"用VMware虚拟机安装Ubuntu后，常常会遇到一个问题：无法联网。那么VMware虚拟机安装Ubuntu如何联网呢？如下内容教你如何在Windows链接有线网络的前提下使VMware虚拟机上的Ubuntu系统链接上网络。","text":"用VMware虚拟机安装Ubuntu后，常常会遇到一个问题：无法联网。那么VMware虚拟机安装Ubuntu如何联网呢？如下内容教你如何在Windows链接有线网络的前提下使VMware虚拟机上的Ubuntu系统链接上网络。 Windows有线网络下VMware虚拟机中Ubuntu系统网络链接1、VMware虚拟机下安装的Ubuntu系统的网络连接方式为NAT模式，具体操作如下图（1）、（2）所示： 在VMware虚拟机中右键Ubuntu系统，点击“设置”进入图（2）；点击“网络适配器”，按图（2）所示”选择NAT模式“即可。 2、Windows下打开“网络共享中心”，按下图（3）、（4）、（5）设置本地连接网络共享。 打开“网络共享中心”，点击“更改适配器设置”进入图（4）；右键“本地连接”，点击“属性”进入图（5）；如图（5）所示，勾选后”确定“。 打开浏览器看看是否可以上网啦！如果不行则往下一步。 3、进入Ubuntu系统，手动设置IPv4，如所示： 进入Ubuntu系统，如图（6）所示，右键右上角的双箭头，选“有线连接1”进入图（7）；双击图（7）中的“有线连接1”，进入图（8）；如图（8）所示，选择“IPv4设置”，选择“方法”为“手动”，点击增加后，手动输入Windows网络中的IPv4的IP地址后”保存“。好啦！现在你在VMware虚拟机下安装的Ubuntu系统可以上网啦！","categories":[],"tags":[]},{"title":"Markdown实用技巧","slug":"TT0010","date":"2017-12-22T00:28:14.470Z","updated":"2018-06-05T07:03:22.133Z","comments":true,"path":"2017/12/22/TT0010/","link":"","permalink":"https://tintingo.github.io/2017/12/22/TT0010/","excerpt":"字体和颜色效果如下：","text":"字体和颜色效果如下： 警告！ 代码如下：1&lt;font color=red face=\"黑体\"&gt;警告！&lt;/font&gt; 引号标记文字效果如下： 你好！代码如下：123&lt;blockquote&gt; &lt;p&gt;你好！&lt;/p&gt;&lt;/blockquote&gt; 显示图片效果如下：代码如下：1![WeChat](/images/WeChat.png) 文字连接1效果如下：https://tintingo.github.io 代码如下：1&lt;https://tintingo.github.io&gt; 文字连接2效果如下：TINTIN 代码如下：1[TINTIN](https://tintingo.github.io) 图片链接效果如下：代码如下：1[&lt;img src=\"https://图片地址\" class=\"nofancybox\" /&gt;](https://链接地址) 注意：在主题…/source/js/script.js文件中的if ($(this).parent().hasClass(‘fancybox’)) return;语句下加上代码:if ($(this).hasClass(‘nofancybox’)) return;","categories":[],"tags":[]},{"title":"Blog风格问题记载","slug":"TT0009","date":"2017-12-21T02:45:05.819Z","updated":"2018-06-05T07:03:28.014Z","comments":true,"path":"2017/12/21/TT0009/","link":"","permalink":"https://tintingo.github.io/2017/12/21/TT0009/","excerpt":"首页预览显示在.md中加:","text":"首页预览显示在.md中加: ;若想在预览中显示图片，则在.md标题处加中加photos，如下：12345---title: Blog风格问题记载photos: - \"/images/T0009.jpg\" #图片地址--- 英文主题汉化找到Blog文件中\\themes\\landscape\\languages文件夹打开，如下图所示，打开zh-CN.yml（中文简体）即可随意汉化。繁体打开zh-TW.yml（台湾繁体）。default.yml为默认主题语言，可将zh-CN.yml或者zh-TW.yml重命名为default.yml。 增加主题按钮选项打开主题配置文件_config.yml，在如下代码后添加：12345# Header Menumenu: Home: / Archives: archives About: about 若是主题中不含有的，则在Blog\\hexo\\source文件夹下自行添加.md文件。比如：我想添加一个生活的按钮，则在Blog\\hexo\\source文件夹下自行添加life.md的文件: 并修改代码为如下：123456# Header Menumenu: Home: / Archives: archives About: about life: life","categories":[],"tags":[]},{"title":"第一个MFC","slug":"TT0008","date":"2017-12-11T08:57:18.313Z","updated":"2018-06-05T07:03:32.927Z","comments":true,"path":"2017/12/11/TT0008/","link":"","permalink":"https://tintingo.github.io/2017/12/11/TT0008/","excerpt":"万事开头难！ 步骤一：新建MFC项目打开Visual Studio，文件–&gt;新建–&gt;项目，如图1所示：","text":"万事开头难！ 步骤一：新建MFC项目打开Visual Studio，文件–&gt;新建–&gt;项目，如图1所示：进入新建项目窗口后，左侧选择已安装–&gt;模板–&gt;Visual C++–&gt;MFC，中间选择MFC应用程序，下方自由命名名称和选择新建项目位置，最后点击确定，如图2所示： 确定后，选择MFC应用程序向导按如下图操作： 以上步骤完成后，进入图8的界面，至此，项目建立完成！ 步骤二：对话框编辑打开左侧工具箱–&gt;对话框编辑器，如图9所示， 删除对话框中确定按钮，从对话框编辑中拖一个Button和一个Edit Control到对话框中，将Button复制四份，Edit Control复制两份，如图10所示： 调整好大小，放好位置，鼠标放在Button右键–&gt;属性，在右下角属性栏的Caption修改按钮名，如图11所示： 步骤三：设置变量与编程鼠标放在Edit Control右键–&gt;添加变量，设置前两个Edit Control变量为E1、E2，设置后一个Edit Control变量为E3，类型：Value，变量类型：float，变量名：E1，如图12所示： 双击每一个控件，就进入主程序中，输入以下代码,运行(本地Windows调试器)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265// MFConeDlg.cpp : 实现文件//#include \"stdafx.h\"#include \"MFCone.h\"#include \"MFConeDlg.h\"#include \"afxdialogex.h\"#ifdef _DEBUG#define new DEBUG_NEW#endif// 用于应用程序“关于”菜单项的 CAboutDlg 对话框class CAboutDlg : public CDialogEx&#123;public: CAboutDlg();// 对话框数据#ifdef AFX_DESIGN_TIME enum &#123; IDD = IDD_ABOUTBOX &#125;;#endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持// 实现protected: DECLARE_MESSAGE_MAP()&#125;;CAboutDlg::CAboutDlg() : CDialogEx(IDD_ABOUTBOX)&#123;&#125;void CAboutDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX);&#125;BEGIN_MESSAGE_MAP(CAboutDlg, CDialogEx)END_MESSAGE_MAP()// CMFConeDlg 对话框CMFConeDlg::CMFConeDlg(CWnd* pParent /*=NULL*/) : CDialogEx(IDD_MFCONE_DIALOG, pParent) , E2(0) , E3(0) , E1(0)&#123; m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);&#125;void CMFConeDlg::DoDataExchange(CDataExchange* pDX)&#123; CDialogEx::DoDataExchange(pDX); DDX_Text(pDX, IDC_EDIT2, E2); DDX_Text(pDX, IDC_EDIT3, E3); DDX_Text(pDX, IDC_EDIT1, E1);&#125;BEGIN_MESSAGE_MAP(CMFConeDlg, CDialogEx) ON_WM_SYSCOMMAND() ON_WM_PAINT() ON_WM_QUERYDRAGICON() ON_BN_CLICKED(IDC_BUTTON1, &amp;CMFConeDlg::OnBnClickedButton1) ON_BN_CLICKED(IDC_BUTTON2, &amp;CMFConeDlg::OnBnClickedButton2) ON_BN_CLICKED(IDC_BUTTON3, &amp;CMFConeDlg::OnBnClickedButton3) ON_BN_CLICKED(IDC_BUTTON4, &amp;CMFConeDlg::OnBnClickedButton4) ON_BN_CLICKED(IDC_BUTTON5, &amp;CMFConeDlg::OnBnClickedButton5) ON_EN_CHANGE(IDC_EDIT2, &amp;CMFConeDlg::OnEnChangeEdit2) ON_EN_CHANGE(IDC_EDIT1, &amp;CMFConeDlg::OnEnChangeEdit1) ON_EN_CHANGE(IDC_EDIT3, &amp;CMFConeDlg::OnEnChangeEdit3) ON_BN_CLICKED(IDCANCEL, &amp;CMFConeDlg::OnBnClickedCancel)END_MESSAGE_MAP()// CMFConeDlg 消息处理程序BOOL CMFConeDlg::OnInitDialog()&#123; CDialogEx::OnInitDialog(); // 将“关于...”菜单项添加到系统菜单中。 // IDM_ABOUTBOX 必须在系统命令范围内。 ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); ASSERT(IDM_ABOUTBOX &lt; 0xF000); CMenu* pSysMenu = GetSystemMenu(FALSE); if (pSysMenu != NULL) &#123; BOOL bNameValid; CString strAboutMenu; bNameValid = strAboutMenu.LoadString(IDS_ABOUTBOX); ASSERT(bNameValid); if (!strAboutMenu.IsEmpty()) &#123; pSysMenu-&gt;AppendMenu(MF_SEPARATOR); pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); &#125; &#125; // 设置此对话框的图标。 当应用程序主窗口不是对话框时，框架将自动 // 执行此操作 SetIcon(m_hIcon, TRUE); // 设置大图标 SetIcon(m_hIcon, FALSE); // 设置小图标 ShowWindow(SW_MINIMIZE); // TODO: 在此添加额外的初始化代码 return TRUE; // 除非将焦点设置到控件，否则返回 TRUE&#125;void CMFConeDlg::OnSysCommand(UINT nID, LPARAM lParam)&#123; if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) &#123; CAboutDlg dlgAbout; dlgAbout.DoModal(); &#125; else &#123; CDialogEx::OnSysCommand(nID, lParam); &#125;&#125;// 如果向对话框添加最小化按钮，则需要下面的代码// 来绘制该图标。 对于使用文档/视图模型的 MFC 应用程序，// 这将由框架自动完成。void CMFConeDlg::OnPaint()&#123; if (IsIconic()) &#123; CPaintDC dc(this); // 用于绘制的设备上下文 SendMessage(WM_ICONERASEBKGND, reinterpret_cast&lt;WPARAM&gt;(dc.GetSafeHdc()), 0); // 使图标在工作区矩形中居中 int cxIcon = GetSystemMetrics(SM_CXICON); int cyIcon = GetSystemMetrics(SM_CYICON); CRect rect; GetClientRect(&amp;rect); int x = (rect.Width() - cxIcon + 1) / 2; int y = (rect.Height() - cyIcon + 1) / 2; // 绘制图标 dc.DrawIcon(x, y, m_hIcon); &#125; else &#123; CDialogEx::OnPaint(); &#125;&#125;//当用户拖动最小化窗口时系统调用此函数取得光标//显示。HCURSOR CMFConeDlg::OnQueryDragIcon()&#123; return static_cast&lt;HCURSOR&gt;(m_hIcon);&#125;void CMFConeDlg::OnBnClickedButton1()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(true);//从控件获得数据赋给变量 E3 = E1 + E2; UpdateData(false);//输出变量的值到控件 &#125;void CMFConeDlg::OnBnClickedButton2()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(true);//从控件获得数据赋给变量 E3 = E1 - E2; UpdateData(false);//输出变量的值到控件 &#125;void CMFConeDlg::OnBnClickedButton3()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(true);//从控件获得数据赋给变量 E3 = E1 * E2; UpdateData(false);//输出变量的值到控件&#125;void CMFConeDlg::OnBnClickedButton4()&#123; // TODO: 在此添加控件通知处理程序代码 UpdateData(true); if (E2 == 0) &#123; MessageBox(_T(\"除数不能为零！\")); return; &#125; E3 = E1 / E2; UpdateData(false);&#125;void CMFConeDlg::OnBnClickedButton5()&#123; // TODO: 在此添加控件通知处理程序代码 E1 = 0; E2 = 0; E3 = 0; UpdateData(false); GotoDlgCtrl((CEdit*)GetDlgItem(IDC_EDIT1));//设置焦点在第一个编辑框&#125;void CMFConeDlg::OnEnChangeEdit2()&#123; // TODO: 如果该控件是 RICHEDIT 控件，它将不 // 发送此通知，除非重写 CDialogEx::OnInitDialog() // 函数并调用 CRichEditCtrl().SetEventMask()， // 同时将 ENM_CHANGE 标志“或”运算到掩码中。 // TODO: 在此添加控件通知处理程序代码&#125;void CMFConeDlg::OnEnChangeEdit1()&#123; // TODO: 如果该控件是 RICHEDIT 控件，它将不 // 发送此通知，除非重写 CDialogEx::OnInitDialog() // 函数并调用 CRichEditCtrl().SetEventMask()， // 同时将 ENM_CHANGE 标志“或”运算到掩码中。 // TODO: 在此添加控件通知处理程序代码&#125;void CMFConeDlg::OnEnChangeEdit3()&#123; // TODO: 如果该控件是 RICHEDIT 控件，它将不 // 发送此通知，除非重写 CDialogEx::OnInitDialog() // 函数并调用 CRichEditCtrl().SetEventMask()， // 同时将 ENM_CHANGE 标志“或”运算到掩码中。 // TODO: 在此添加控件通知处理程序代码&#125;void CMFConeDlg::OnBnClickedCancel()&#123; // TODO: 在此添加控件通知处理程序代码 CDialogEx::OnCancel();&#125; 打开刚刚的新建项目目录：MFCone/Debug里就有个MFCone.exe，点击运行就成功了，如图13 完成喽！","categories":[],"tags":[]},{"title":"JAVA Web学习笔记","slug":"TT0007","date":"2017-12-11T08:57:18.312Z","updated":"2018-06-05T07:03:38.433Z","comments":true,"path":"2017/12/11/TT0007/","link":"","permalink":"https://tintingo.github.io/2017/12/11/TT0007/","excerpt":"声明：以下内容为学习范立锋等《Java Web程序设计教程》的笔记，大部分内容均出自原文！ 一、XMLXML-可拓展标记语言，是一种数据存储语言，用简单的标记来描述数据，其中，XML文件以.xml结尾。","text":"声明：以下内容为学习范立锋等《Java Web程序设计教程》的笔记，大部分内容均出自原文！ 一、XMLXML-可拓展标记语言，是一种数据存储语言，用简单的标记来描述数据，其中，XML文件以.xml结尾。1234567&lt;?xml version=\"1.0\" enconding=\"GB2312\"?&gt; %声明：版本号1.0；字符编码格式中文&lt;person&gt; %根元素，一个xml中只能有一个根元素，其他元素都包含在其中； &lt;!--姓名--!&gt; %注释 &lt;name&gt;TINTIN&lt;/name&gt; %元素 &lt;!--性别--!&gt; &lt;sex&gt;男&lt;/sex&gt;&lt;/person&gt; xml常见用途：1.不同应用程序间数据交互：xml提供一种不同应用程序间数据交互的公共标准；2.一种是数据多种样式：xml将信息的数据和显示样式分离开来（样式需用其他语言来定义，如CSS），这样同一份数据可添加多种式样；3.数据的分布式处理：xml可在Internet上自由传送，客户可从xml中提取到数据，因此，数据处理可在客户端完成，无需返回Web服务器，节省了Internet上的数据宽带。 二、CSSCSS-层叠样式表单，是一种表现HTML或XML等文件式样的语言（浏览器解释语言）。CSS语法包括：CSS选择符、CSS属性。（每个CSS选择符可包含一或多个CSS属性）12格式：选择符&#123;属性&#125;body&#123;color:blue&#125; %在&lt;body&gt;标记内，文本颜色为蓝色 XML中选择符可为标记名称或标记名称的id/class属性值。123456&lt;?xml version=\"1.0\" enconding=\"GB2312\"?&gt;&lt;?xml-stylesheet type=\"text/css\" href=\"game.css\"?&gt; %XML引用CSS文件格式，href值为.CSS的地址&lt;person&gt; &lt;name id=\"myNAME\"&gt;TINTIN&lt;/name&gt; &lt;sex class=\"yourSEX\"&gt;男&lt;/sex&gt;&lt;/person&gt; id属性的值是唯一的，唯一标记一个标记，而class属性可标记一组标记1234id格式：#id名&#123;属性1;属性2&#125;#myNAME&#123;color：black;size:10px&#125;class格式：.class名&#123;属性;属性2&#125;.yourSEX&#123;color：blue;size:10px&#125; CSS代码也可直接写到XML代码中，但不方便维护，故不推荐使用。 三、JavaScriptJavaScript是一种允许在HTML基础上进行交互式Web网页开发的脚本语言，JavaScript大多用在客户端数据校验，减轻了服务器的负载量，使客户浏览更流畅。HTML使用JavaScript的两种方式：1.外部引用：123456789&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\" src=\"game.js\"&gt;&lt;/script&gt; %可在&lt;head&gt;或&lt;body&gt;中如何地方出现 &lt;/head&gt; &lt;body&gt; &lt;p id=\"hello\"&gt;你好！&lt;/p&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;打招呼&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 其中，game.js中可以添加任意多的类和函数，实际应用推荐使用外部引用方式，这样更安全也更易维护。game.js文件如下：1234function myFunction()&#123;document.getElementById(\"hello\").innerHTML=\"Hello!\";&#125; 2.内部调用：1234567891011121314&lt;html&gt; &lt;body&gt; &lt;p id=\"hello\"&gt;你好！&lt;/p&gt; &lt;button type=\"button\" onclick=\"myFunction()\"&gt;打招呼&lt;/button&gt; &lt;script type=\"text/javascript\"&gt; &lt;!-- %加注释是为了防止浏览器不支持javascript时出现源码 function myFunction() &#123; document.getElementById(\"hello\").innerHTML=\"Hello!\"; &#125; //--&gt; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 四、Ajax当用户填写完信息提交表单时，会向服务器发送请求，服务器收到请求并处理表单数据后才会给用户新页面。但当大量用户同时发出请求时，由于服务器需要处理大量请求会导致用户刷新页面变慢，此时，Ajax就至关重要了。Ajax是一种结合了XML和JavaScript等技术建立交互式网页应用的技术。Ajax包含技术：XML、CSS、JavaScript、XMLHttpRequest、DOM、XHTML、XSLT。","categories":[],"tags":[]},{"title":"HTML5基础代码","slug":"TT0006","date":"2017-12-11T08:57:18.311Z","updated":"2018-06-05T07:03:43.861Z","comments":true,"path":"2017/12/11/TT0006/","link":"","permalink":"https://tintingo.github.io/2017/12/11/TT0006/","excerpt":"设置标签页logo1&lt;link rel=\"icon\" href=\"images/log.png\"/&gt;","text":"设置标签页logo1&lt;link rel=\"icon\" href=\"images/log.png\"/&gt; 设置背景图片1&lt;body background=\"images/BG3.jpg\"&gt; 设置段落格式1&lt;p style=\"font-family:arial;color:black;font-size:35px;text-align:center;\"&gt; 设置图片超链接12341.当前页面打开&lt;a href=\"https://***.com/\"&gt;&lt;img border=\"0\" src=\"images/download.png\" alt=\"Download\" width=\"30\" height=\"30\"&gt;下载&lt;/a&gt;2.新页面打开&lt;a href=\"https://***.com/\" target=\"_black\"&gt;&lt;img border=\"0\" src=\"images/download.png\" alt=\"Download\" width=\"30\" height=\"30\"&gt;下载&lt;/a&gt; 空格1&amp;nbsp 画横线1234561.虚线（dashed）&lt;hr style=\"height:10px;border:none;border-top:10px dashed black;\" /&gt;2.实线（solid）&lt;hr style=\"height:10px;border:none;border-top:10px solid black;\" /&gt;3.双实线（上颜色：black；下颜色：blue）&lt;hr style=\"height:10px;border:none;border-top:10px black blue;\" /&gt; 正文图片1&lt;div align=\"center\" style=\"background-color:honeydew\"&gt;&lt;img src=\"images/f001.jpg\" style=\"width:100%;\"/&gt;&lt;/div&gt;","categories":[],"tags":[]},{"title":"音乐|视频更新","slug":"TT0005","date":"2017-12-11T08:57:18.310Z","updated":"2018-06-05T07:03:48.758Z","comments":true,"path":"2017/12/11/TT0005/","link":"","permalink":"https://tintingo.github.io/2017/12/11/TT0005/","excerpt":"插入视频法（一）12345&lt;iframe align=center width=\"736\" height=\"400\" src=\"/movies/M01.mp4\" frameborder=0 allowfullscreen&gt; &lt;/iframe&gt;","text":"插入视频法（一）12345&lt;iframe align=center width=\"736\" height=\"400\" src=\"/movies/M01.mp4\" frameborder=0 allowfullscreen&gt; &lt;/iframe&gt; src=”/movies/M01.mp4”为视频地址。 法（二）123&lt;video width=\"736\" height=\"400\" controls&gt;&lt;source src=\"/movies/M01.mp4\"&gt;&lt;/video&gt; 插入音乐123&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=736 height=260 src=\"/musics/m001.mp3\"&gt; &lt;/iframe&gt;","categories":[],"tags":[]},{"title":"一些常用Matlab代码记录","slug":"TT0003","date":"2017-12-11T08:57:18.309Z","updated":"2018-09-18T01:23:55.462Z","comments":true,"path":"2017/12/11/TT0003/","link":"","permalink":"https://tintingo.github.io/2017/12/11/TT0003/","excerpt":"记忆力差？用过的代码老忘记？一次又一次的上网搜?好浪费时间！写在博客里方便随时查阅~~~~","text":"记忆力差？用过的代码老忘记？一次又一次的上网搜?好浪费时间！写在博客里方便随时查阅~~~~ 常用读写方式Excel读写（xlsread、xlswrite）123456%读mytxt = xlsread('C:/filename.xls')%写txt = ['a' 's' 'd' 'f' 'g' 'h'];mytxt = xlswrite('C:/filename.xls',txt) txt读写12345678910111213141516171819202122%读fid = fopen('C:/words.txt','r');txt = textscan(fid,'%s');fclose(fid);%解决中文乱码问题(法一)【TXT文件默认“ANSI”编码，转成“UTF-8”编码】encoding = 'UTF-8';currentCharacterEncoding = slCharacterEncoding();slCharacterEncoding(encoding) %encoding 为设置的具体的编码模式fid = fopen('C:/words.txt','r');txt = textscan(fid,'%s');fclose(fid);% 缺点：接下来整个程序都按“UTF-8”编码方式运行。%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%解决中文乱码问题(法二)【TXT文件默认“ANSI”编码，转成“UTF-8”编码】fp = fopen('test.txt','r','n','utf-8');s2 = fgets(fp)% 优点：仅仅此段程序按“UTF-8”编码方式运行，其他不变。%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%写txt = ['a' 's' 'd' 'f' 'g' 'h'];dlmwrite('C:/myfile.txt', txt, 'delimiter', '\\t') HTML写入123fid = fopen('MY.html','w+');fprintf(fid,'%s',HTML&#123;1&#125;)fclose(fid) 图片读写12345%读I = imread('C:/im01.jpg');%写imwrite(I,'C:/im01.jpg'); mat读写1234567%读Data = load('C:/myfile.mat')%%写save DATA %workspace中的内容全部保存save data.mat -regexp '[^data1 ^data2]' %保存workspace中除data1和data2的内容%也可在workspace中想要保存的内容右键保存 矩阵随机交换行（列）123456789% 给矩阵A随机换行A = [1 2 3; 4 5 6; 7 8 9; 10 11 12] h = randperm(size(A, 1)); %randperm生成1:size(A, 1)的随机数 B = A(h,:)% 给矩阵A随机换行A = [1 2 3; 4 5 6; 7 8 9; 10 11 12] l = randperm(size(A, 2)); C = A(:,l) 比较两匹配123A = ['AAA'];B = ['BBB'];result = strcmpi(A,B); %结果为1，A、B相同，结果为0，A、B不同 打开文件夹1filename = uigetdir('选择一个目录'); 超链接1web https://tintingo.github.io/ -browser; 弹出对话框1msgbox(' 任务完成！') GUI常用命令GUI按钮换背景图12I = importdata('image\\eye.jpg');set(handles.pushbutton1,'CDATA',I); GUI更换自己的logo1234h = handles.figure1; newIcon = javax.swing.ImageIcon('image\\logo.jpg');figFrame = get(h,'JavaFrame'); figFrame.setFigureIcon(newIcon); GUI更设置面背景123456Hd_axes = axes('units','normalized','position',[0 0 1 1],'tag','Hd_axes');uistack(Hd_axes,'down')II = imread('image\\background.jpg');image(II)colormap grayset(Hd_axes,'handlevisibility','off','visible','off'); GUI可编辑文本框显示文字1set(handles.edit1, 'String','文字') GUI获取可编辑文本框里的文字1txt = get(handles.edit1,'string'); GUI可编辑文本框显示时间123function timercallback(obj, event,handles)str = datestr(now, 'HH:MM:SS');set(handles.edit1, 'String',str); GUI打包成exe1deploytool GUI显示动图图12345678910axes(handles.axes1);theta=linspace(0,110*pi,100);x=cos(theta);y=sin(theta);h=line(x,y);axis([-0.1 5 -0.2 0.2])set(h,'erasemode','xor')for n=1:60 set(h,'xdata',x+n*.1); pause(0.05)end GUI弹出式菜单操作123先双击修改“String”为被选择项名词，get(handles.popupmenu1, 'value');返回1、2、3为对用选项值。 画网络结构图自定义节点名12labels = &#123;'one','two','three','four'&#125;;draw_graph(dag,labels); 画网络结构图的两种方式12draw_graph( dag ); %dag为网络结构边的关系h = view(biograph( dag )); matlab关联.m文件（安装了matlab，但无法双击打开.m文件）法一1234cwd=pwd;cd([matlabroot '\\toolbox\\matlab\\winfun\\private']);fileassoc('add',&#123;'.m','.mat','.fig','.p','.mdl',['.' mexext]&#125;); cd(cwd); 法二123456步骤1：到本站下载页下载标题为“matlab关联.m文件”的文件步骤2：（1）解压后，运行matlab软件 -&gt; 打开 -&gt; associateFiles.m -&gt; F5运行 （2）运行完毕后文件夹中会生成一个.reg文件，双击该文件，完成即可（3）找一个.m文件,右键 -&gt; 打开方式，若有matlab选项，说明关联成功 生成‘ABCDE’这5个字母的随机组合1s = perms('ABCDE'); %随机生成Cnn种组合 同一figure显示多个图1subplot(n,m,i) %一个figure分为n行，m列。i表示第i个图。 22.给一个数列（矩阵）里的数排序（从大到小）123[a b]=sort(A(:)); %从小到大排序a = fliplr(a'); %取倒序b = fliplr(b'); 字符匹配判断两字符是否匹配1234567891011&gt;&gt; regexpi('asdf','asdf')ans = 1&gt;&gt; regexpi('asdf','agsdf')ans = [] 判断字符Str中是否含有‘http’字符1234567891011&gt;&gt; Str='httpthestartingindicesoft';strfind(Str,'http')ans = 1&gt;&gt; Str='httpthestartingindicesofthttp';strfind(Str,'http')ans = 1 26 消除matlAB启动时的Warning：Name is nonexistent or not a directory…12步骤：file -&gt; set path -&gt; Defualt -&gt; Yes -&gt; 重启matlab 删除cell中的空元素1A(cellfun(@isempty,A)) = []; matlab添加工具箱1234567步骤1：将工具箱文件夹放到matlab安装目录下的toolbox下；步骤2：addpath(genpath('C:\\MATLAB\\toolbox\\BNT')); savepath; 步骤3：which test_BNT.m %test_BNT.m为工具箱任意中的一个函数，若返回路径，则添加成功 matlab批量读取文件夹中的文本1234567891011121314for j = 1:215 # 文件夹个数 for i = 1:300 # 每个文件夹中文本个数 eval(['fid = fopen','(','''','G:/DMAIL/2006年TREC公共垃圾邮件语料库（中文）/trec06c/data/',int2str(j),'/',int2str(i),'''',',','''','r','''',')',';']) %fid = fopen('G:/DMAIL/2006年TREC公共垃圾邮件语料库（中文）/trec06c/data/000/000','r'); txt = textscan(fid,'%s'); fclose(fid); TREC06cWords01 = char((cellstr(txt&#123;1,1&#125;))'); TREC06cWords02 = []; for ii = 1:size(TREC06cWords01,1) TREC06cWords02 = strcat(TREC06cWords02,TREC06cWords01(ii,:)); end TREC06cWords&#123;j,i&#125; = TREC06cWords02; endend 横坐标等间距画条形图（实际值不等距画成不等间）1234567x=[100;200;300;400;500];% 先将横坐标设为等距y1=[6.1;6.4;7.0;7.2;7.5];y2=[6.8;7.2;7.4;7.7;7.8];y3=[4.5;5.1;5.3;5.7;5.9];y=[y1,y2,y3];bar(x,y); %画条形图set(gca,'XTickLabel',&#123;'500','1000','3000','5000','8000'&#125;); % 将横坐标修改为实际值 新建任意格式的文件（以.doc文件为例）123456txt = ‘文件名’;txtname = [txt,'.txt'];docname = [txt,'.doc'];fp = fopen(txtname,'w');fclose(fp);eval(['!rename' , ' ' ,txtname, ',',docname]); 找一个矩阵是否在另一个矩阵中出现（找到行）123456789101112131415B = magic(10);A = B(3:4, 4:7); % 测试数据sA = size(A);sB = size(B);k = 0;C = [];for i = 1:sB(1)-sA(1)+1 for j = 1:sB(2)-sA(2)+1 if isequal(A, B(i:i+sA(1)-1, j:j+sA(2)-1)) k = k+1; C(k,1:2) = [i j]; end endend 找一个矩阵是否在另一个矩阵中出现（找到列）123A = [1,2,3,1;2,3,4,2;3,3,8,3];B = [1;2;3];C = find((ismember(A',B','rows'))') 判断某路径下某文件是否存在1~exist('C:\\TEST\\test.m','file') %为0表示路径C:\\TEST下文件test.m存在，为1则无。 Solve函数求解多输入等式解，获取解的值(X = [1 2 3 4 5];Y = [5 4 3 2 1];求等式：X(i)*w=Y(i)的w值)1234for i=1:size(input,2)eval(['W(i) = solve(','''',num2str(X(i)),'*w=',num2str(Y(i)),'''',',','''','w','''',');'])endW = double(W); 对数列排序时，出现相同大小的数，如何获取让排序位置不重复1234a = [1 2 8 5 6 4 3 4 2 5 1 9];b = a+rand(1,size(a,2))*0.001;% 将数列统一加上一个极小的随机数c = sort(b,'descend');index = arrayfun(@(x) find(b(x)==c),1:numel(b),'un',0); GUIDE最大最小化 #进度条123456Num = 10000; % 待处理问题个数h = waitbar(0,'正在运行，请等待...');for k = 1:Num waitbar(k/Num)endclose(h) Gibbs抽样推理引擎使用直接使用bnt贝叶斯工具箱中的Gibbs抽样推理引擎@gibbs_sampling_inf_engine时会提示：compute_posterior函数未定义，因为工具箱中确实没用compute_posterior.m文件，有的是compute_posterior.c文件，故在使用前需做一下工作：进入@gibbs_sampling_inf_engine\\private文件夹中找到compute_posterior.c和compute_posterior.c这两个.c文件，将文件复制到主函数同一目录下，并运行如下两段代码：12mex compute_posterior.cmex sample_single_discrete.c 编译完成后，将会生成compute_posterior.mexw64和sample_single_discrete.mexw64这两个文件，接下来再次运行主程序就不会提示错误啦！","categories":[],"tags":[]},{"title":"如何用Matlab设计GUI？","slug":"TT0002","date":"2017-12-11T08:57:18.308Z","updated":"2018-06-05T07:03:54.430Z","comments":true,"path":"2017/12/11/TT0002/","link":"","permalink":"https://tintingo.github.io/2017/12/11/TT0002/","excerpt":"什么是GUI？matlab编程可以设计GUI吗？GUI定义:GUI指的是图形用户界面（Graphical User Interface，GUI），也称之为图形用户接口，GUI是用图形化方式显示的计算机操作用户界面（可视化）。我们通常都是使用matlab来做计算，matlab还可以设计GUI？matlab编当然可以设计GUI！那么，使用matlab到底如何设计GUI呢？往下看喽！","text":"什么是GUI？matlab编程可以设计GUI吗？GUI定义:GUI指的是图形用户界面（Graphical User Interface，GUI），也称之为图形用户接口，GUI是用图形化方式显示的计算机操作用户界面（可视化）。我们通常都是使用matlab来做计算，matlab还可以设计GUI？matlab编当然可以设计GUI！那么，使用matlab到底如何设计GUI呢？往下看喽！ 步骤一：新建GUI打开Matlab，在Command Window输入命令：1guide 回车后打开窗口如下 图1图1中有四种GUI可选，在此选第一个“Blank GUI（Default）”空白的GUI。OK后来到如下窗口： 图2图2左侧有14个常用GUI属性可选，包括：按钮（Button），滑块（Slider），单选按钮（Radio Button），复选框（Check Box），编辑文本（Edit Text），静态文本(Static Text)，上托项目单（Pop-up Menu），列表框（Listbox），开关按钮（Toggle Button），列表（Table），坐标轴（Axes），面板（Panel），按钮组（Button Group），ActiveX控件（ActiveX Control）.在此，我们先做个简单的“显示图片”的GUI看看。将左侧“坐标轴（Axes）”和“按钮（Button）”各一个拖入操作区并自定义大小，如图3所示：图3保存后除了你自定义文件名的.fig文件外，还会自动生成一个与你命名相同的.m文件，到此，新建GUI完成。 步骤二：fig自定义在Matlab右键上面生成的.fig文件，选择“Open in GUIDE”使用GUIDE打开，双击以上添加的坐标轴或者按钮打开用户控件信息如图4所示：图4你可在图4中修改任意参数来改变控件的属性，包括：尺寸，文字，颜色等。在此就不一一介绍喽！比如：我修改按钮中的FontSize为：15.0，将String改为：选择图片，就会出现如图5所示效果：图5到此，就可得到你想要的GUI界面喽！ 步骤三：程序编辑双击打开上面生成的.m文件，在pushbutton1_Callback(hObject, eventdata, handles)函数处编写如下代码：123456789101112% --- Executes on button press in pushbutton1.function pushbutton1_Callback(hObject, eventdata, handles)% hObject handle to pushbutton1 (see GCBO)% eventdata reserved - to be defined in a future version of MATLAB% handles structure with handles and user data (see GUIDATA)[filename,filepath] = uigetfile(&#123;'*.bmp;*.jpg;*.png;*.jpeg;*.tif',... '文件类型 (*.bmp,*.jpg,*.png,*.jpeg,*.tif)';'*.*', '所有文件(*.*)'&#125;,... 'Pick an image');file = strcat(filepath,filename);in = imread(file);axes(handles.axes1);imshow(in); F5运行后就可看到如下效果：图6点击“选择图片”按钮进入图7选择图片文件窗口：图7选择图片后就可显示出来，如图8所示：图8 怎么样！开心吧！我的第一个GUI完成了！后续还将会进一步学习！","categories":[],"tags":[]},{"title":"如何搭建个人博客？","slug":"TT0001","date":"2017-11-04T03:03:44.397Z","updated":"2018-06-05T07:02:57.397Z","comments":true,"path":"2017/11/04/TT0001/","link":"","permalink":"https://tintingo.github.io/2017/11/04/TT0001/","excerpt":"当你遇到一个似曾相识的知识却突然想不起来时：你需要一个个人博客！当你觉得一段经历难忘而值得分享却不知所措时：你需要一个个人博客！","text":"当你遇到一个似曾相识的知识却突然想不起来时：你需要一个个人博客！当你觉得一段经历难忘而值得分享却不知所措时：你需要一个个人博客！ 哎呦！不错哟！博主在网上搜索了多种方法，折腾了1天都没成功（都有坑），还一度想放弃搭建，但“柳暗花明又一村”的是，我综合了多篇博文，终于我成功了！在此：哈哈大笑！网络上的方法很多，您可以搜搜看，当然，您也可以往下看！ 现在开始步骤一：下载安装软件到官网下载： NodeJs Git (在官网上无法下载的话，可以到“白杜云”上搜索下载)安装NodeJs时按正常步骤就行，安装Git时需要注意如下： 安装完成后，“win+R”打开“运行”键入“cmd”回车进入命令窗口，输入如下命令：12node -vgit -–version 若返回版本信息则说明安装成功，否则就重新安装吧！ 安装Hexo随便在电脑桌面或者任意盘内新建一个文件夹，命名为“Blog”，在该文件夹中“shift+右键”选用“Git Bash”打开命令窗口，并键入如下命令：12$ npm install -g hexo $ hexo 返回hexo信息则说明安装成功！紧接着输入：1$ hexo init hexo 步骤二：新建仓库（New repository）在你注册了GitHub账号后，点击“New repository”创建仓库，注意：命名时应命名为username.github.io，其中，username为你几己的GitHub用户名。 到之前新建的文件夹的“hexo”文件夹下“shift+右键”选用“Git Bash”打开命令窗口，并键入如下命令：12$ cd C:/Users/Administrator/.ssh$ ssh-keygen -t rsa -C \"####@163.com（注册GitHub时的邮箱）\" 一直回车，和“Y”即可。在你的GitHub找到“Settings”，打开左下角有个“SSH and GPG keys”，点击“New SSH key”输入标题后在地址：“C:/Users/Administrator/.ssh”找到id_rsa.pub打开将里面的内容全部复制，并粘贴到“key”里，按下“Add SSH key”即可。 现在，回到之前新建的文件夹的“hexo”文件夹下“shift+右键”选用“Git Bash”打开命令窗口，并键入如下命令：123$ npm install$ hexo generate$ hexo server 访问：http://localhost:4000/若出现初始化的博客，则“Ctrl+C”停止刚才的命令。 步骤三：网站配置在之前新建的文件夹的“hexo”文件夹下找到_config.yml文件打开，在内容最后12deploy: type: 修改为如下： 1234deploy: type: git repository: git@github.com:**********.github.io.git #SSH地址在你上面新建的GitHub仓库里点击“Clone or download”选“Use SSH”并复制到此 branch: master 好啦！通过访问你的GitHub地址https://username.github.io即可看到属于你自己的博客喽！（注意：地址中的username更换成你几己的GitHub用户名即可） 步骤四：更新博客建好自己的博客后，就迫不及待的想将自己的想写的东西放在上面喽！首先：在你建博客的文件夹目录下“shift+右键”选用“Git Bash”打开命令窗口，并键入如下命令：1$ hexo new newblog （注意：newblog为你新建博客的文件名，可随意取名（没试过中文名）） 在你建博客的文件夹目录下的source/_post目录下找newblog.md文件，打开内容就可以按照自己意愿修改喽！ 然后，同样在你建博客的文件夹目录下“shift+右键”选用“Git Bash”打开命令窗口，并键入如下命令：1234567$ hexo clean$ hexo g$ npm install hexo-deployer-git --save$ hexo d 好了，访问https://username.github.io看看吧！（注意：如果没有显示不用担心，多刷新几遍就出来了。如果实在还是没有的话，以上操作重新来过！） 就写到这吧！怎么更改主题再学习吧！","categories":[],"tags":[]}]}